[toc]

----

# Bedrock

## 一、导论

### 1、功能简述

Bedrock（基岩），是为一个类似于工具包的项目。旨在开源个人开发的一些功能模块化类。如当前基于 Redis 分布式独锁和联合锁。在未来将有其他的一些小工具类添加到其中。

### 2、模块划分

当前划分为两个模块 Slate 和 Ecosphere。在 Slate（岩板）模块的 src/main 目录存放开发完成的模块化类，而 Ecosphere （生态圈）则是在 src/test 存放针对这些类的测试用例。

当前 Ecosphere  使用 SpringBoot V2.7.17。整个项目中所用到的依赖均和 spring-boot-dependencies 保持一致。

## 二、功能模块

### 1、分布式锁

#### 1.1、简述

对于分布式锁来说，可以基于 Redis 也可以基于 Zookeeper 实现。当前只开发出基于 Redis 的分布式锁——分布式全局独锁、分布式全局联合锁。它们都继承自 JUC Lock 接口，其在原理上即是自旋锁也是阻塞锁，支持锁的互斥、重入性，阻塞性，能杜绝死锁的产生。

#### 1.2、锁结构与相关特性

使用 Redis 的 Hash 数据结构来描述分布式锁。可在工厂类中自由指定分布式锁名称，而程序将自动更具线程名称生成锁持有者标识。

单次加锁动作，若存在锁则锁重入计数递增 1，未存在则创建分布式锁并设置重入计数为 1。单次解锁动作即将重入计数递减 1。计数归零时代表锁释放。

#### 1.3、分布式独锁

针对单一服务器实例加锁和解锁，在当前的设定中又两种锁：Redis 分布式全局独锁和 Zookeeper 全局独锁。但是 Zookeeper 全局独锁暂未实现。

对于 Redis 分布式全局独锁（RedisDistributedGlobalSingleLock）来说，在整个应用程序运行当中只需要创建一次，之后即可在应用程序的任何地方调用其 Lock 接口的任意方法实现加锁和解锁。对比同类型的 Redission 中的 RLock，回避了其需要多次创建的弊端，有效的减轻了 GC 的负担。其内部原理为将线程所需的各项参数封装为一个上下文对象，之后存储到 ThreadLocal 当中。这样数据即无参可跨方法传递。

**使用方法**

使用`DistributedGlobalSingleLockFactory`构建`RedisDistributedGlobalSingleLock`实例，之后即可全局容易地方使用

#### 1.4、分布式联合锁

针对多个 Redis 实例加锁和解锁，与独锁同样，其也是一把全局锁，之需创建一次即可在任何地方使用。其设计借鉴了 Redis 之父 的 RedLock 算法。目的是可使用冗余节点避免 Redis 服务器宕机时造成的锁丢失的问题。

**使用方法**

使用`DistributedGlobalCombinationLockFactory`构建`RedisDistributedGlobalCombinationLock`实例，之后即可全局容易地方使用

##### 1.4.1、锁丢失问题

在线程加锁的过程中，可能出现之前已经加锁成功的 Redis 服务器突然宕机，当其再次可用之后会导致已添加的锁超时失效的情况。这就被称为锁丢失。

##### 1.4.2、联合锁之中的竞争

依据 RedLock 之中的思路，通过对 Redis 多个实例的加锁来解决锁丢失问题，这这个方法极大的保证的程序的高可用性。但是这就带来了另外一个问题：多线程同时对多个 Redis 实例加锁，如何保证有效性，如何在容错的前提下保证锁竞争的互斥呢？

对于这个问题，我的解决方案是：顺序竞锁 + 最左权重原则。

**顺序竞锁**

所有线程按 Redis 实例节点传入顺序从左至右申请加锁。这样可避免死锁的发生。同样在解锁时采用逆序解锁。

**最左权重原则**

在联合锁的竞争中，第一位加锁成功的线程并不永远锁的第一持有人（第一名并不永远都是第一名）。可能其加锁成功的 Redis 实例会在判定联合锁加锁成功期间全部出现宕机，之后其他线程后发先至的判断当前无分布式锁，所以”顺理成章“的获得了下一 Redis 实例的锁。此时第一位加锁成功的线程就好像没有加锁成功一样，那么鉴于这个后发者好像合理的持有了分布式锁也就只能判定第一位加锁成功的线程竞争锁失败，此时由后发者继续进行后续加锁，若其未加锁超时则可判定其联合锁加锁成功。

这种若一个线程一旦先于其他线程在左端加锁成功即可额获得之后 Redis 实例的加锁机会，而其他线程一旦竞争失败则只能等待，这就是最左权重原则。

在最左权重原则中，第一名并非永远都是第一名，它需要准备和其他线程进行全线争斗，只有在一个恒定节点上力压群雄才能最终竞争得锁，并且这个过程不能超时。

- 案例

  假如当前有 Redis 节点 A、B、C、D、E。当前有两个线程同时开始竞争联合锁。在 T0 时间，线程 1 在 A 节点添加独锁成功，接下需去 B 节点加锁。但 T1 时，A 节点突然宕机，此时线程 2 刚好开始竞争，因为 A 节点宕机则其跳过 A 而从 B 节点开始竞争。在 T2 时，线程 2 对 B 节点加锁成功，而线程 1 则加锁失败，此时从锁的角度来看，是线程 2 持有了分布式锁。在 T3 时，若有其他线程来竞争分布式锁，在发现 B 节点存在线程 2 的锁，那么就会结束竞争转而等待。

**加锁成功的判断**

在不突破最小可用节点数的情况下，对所有可用的 Redis 实例加锁成功且全程未超时。在可控制锁超时时间的情况下，只要保证全部节点加锁成功即可，若节点宕机则会自动跳过，不会出现不连续节点

##### 1.4.3、联合锁当中的时间参数

**独锁操作时间**

联合锁，本质就是联合多个独锁，而对每个 Redis 实例的加锁操作即视为一个独锁操作。而独锁操作时间是为了更加直观的控制联合锁中各个独锁的使用效率而定，通过其可以使用套用公式显而易见的得到整个联合锁的加锁超时时间。

**联合锁的加锁超时时间**

若有设定超时时间则为设定时间，未设置则为基础等待时间（独锁操作时间 * 锁数量 + 100）。单位为毫秒

##### 1.4.4、节点容错中的异常传播和不可用节点自动重试

在加锁时，若 Redis 宕机则会触发`RedisCommandTimeoutException`异常。命令超时参数由传入的 RedisURI 携带。若为设置则默认设置 5ms 的超时时间。在触发该异常时，会标识当前 Redis 节点不可用，同时记录节点不可用开始时间。这个不可用标识时全局的。设置的目的是避免对不可用节点的大量访问。

> RedisConnectionException 异常为保险起见而为之，在锁的运行期间 debug 调试，未碰见触发这个异常的情况，当然如果传入的 RedisURI 有误则会在工厂类的初始化逻辑中触发这个异常。

联合锁默认会从不可用开始时间之后的 15 分钟对节点执行 ping 操作。若 ping-pong 机制正常则立即标识该节点可用，反之（抛出异常）则刷新不可用开始时间。并等待下一周期的测试。间隔重试时间可在工厂类构造器中指定，单位为毫秒。

#### 1.5、自实现的 AQS

在初始的分布式锁中，独锁和联合锁并不是全局可用的。使用方式是使用一次而创建一次。并且底层虽然使用 Lua 脚本保证锁操作的原子性，但线程之间的竞争是直接通过 CAS 自旋等待来实现的。这在小量并发下可能无妨，但高并发下就暴露了其对 GC 不友好和过量占用 CPU 的问题。

所以为了优化 GC 不友好这个问题，独锁和联合锁改进为了全局锁。而为了避免 CAS 过量占用 CPU 资源则使用 LockSupport 来阻塞和唤醒线程。

考量到代码的优雅和扩展性，特借鉴于 JUC 的 AQS ，在保留整体框架逻辑的同时，也对其进行了部分改装和设计方面的妥协。比如：

- 添加了部分回调方法
- 对`unsafe`类的不通转而只能使用`AtomicReference`来操作队列的头节点和尾节点。不过虽然是代码设计方面的妥协，但并不会造成节点丢失的问题，因为头节点和尾节点的更新操作都是原子的，而队列中也就只有这两点会有大量线程竞争，保证了头节点和尾节点的原子性更新即保证了整个队列的有效性。

相比于 JUC 的AQS，自实现的 AbstractQueuedSynchronizer 只维护一个有序访问流，这是一个双向的 FIFO 链表。其核心逻辑就是依据这个有序链表利用 LockSupport 实现线程的等待与被动唤醒机制，从而避免了高并发下大量的 CAS 自旋等待竞争。

**Competitor**

AbstractQueuedSynchronizer 能接受一个 Competitor 接口类型的泛型参数，其表明链表节点中存储的对象类型。

```java
public abstract class AbstractQueuedSynchronizer<T extends Competitor> extends AbstractExclusiveAccessSynchronizer {
	...
}
```

Competitor 是一个锁竞争者标记接口。其内部定义了四种回调方法，会在 AQS 队列节点的执行期间顺序调用。而其子类则会封装竞争者特有的数据，便于在 AQS 的执行逻辑中访问和调用。

对于每个 Competitor 实现类来说，其 equals、hashCode 总是比对它的锁持有者标识。因为 ASQ 中的 Competitor  实例间比对都是使用`==`，这样它效率最高。











